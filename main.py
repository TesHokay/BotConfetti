"""Entrypoint for the Confetti Telegram bot.

This module now contains a functional scenario for the Confetti studio bot.
The implementation mirrors the structure that is used in production while
remaining small enough for the accompanying exercises.

As in the original project we attempt to instantiate
``AIORateLimiter`` inside :func:`ConfettiTelegramBot._build_rate_limiter`.  If
the optional extra is missing the class is still importable but its
constructor raises a :class:`RuntimeError`.  We catch the exception and log a
warning which allows the bot to start without the rate limiter.
"""

from __future__ import annotations

import logging
import os
import random
import re
from datetime import datetime
from pathlib import Path
from zipfile import ZIP_DEFLATED, ZipFile
from collections.abc import Iterable
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any, Dict, Optional, Union
from xml.sax.saxutils import escape


TELEGRAM_IMPORT_ERROR: ModuleNotFoundError | None = None

_TELEGRAM_DEPENDENCY_INSTRUCTIONS = (
    "python-telegram-bot is required to run this project. "
    "Install it with 'pip install \"python-telegram-bot[rate-limiter]\"'."
)


class _MissingTelegramModule:
    """Placeholder that raises a helpful error when used without telegram."""

    def __getattr__(self, name: str) -> Any:  # pragma: no cover - guard clause
        if TELEGRAM_IMPORT_ERROR is not None:
            raise RuntimeError(_TELEGRAM_DEPENDENCY_INSTRUCTIONS) from TELEGRAM_IMPORT_ERROR
        raise RuntimeError(_TELEGRAM_DEPENDENCY_INSTRUCTIONS)


if TYPE_CHECKING:
    from telegram import KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
    from telegram.ext import (
        AIORateLimiter as _AIORateLimiter,
        Application,
        ApplicationBuilder,
        CommandHandler,
        ContextTypes,
        ConversationHandler,
        MessageHandler,
        filters,
    )
else:  # pragma: no cover - import depends on environment
    try:
        from telegram import KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
        from telegram.ext import (
            Application,
            ApplicationBuilder,
            CommandHandler,
            ContextTypes,
            ConversationHandler,
            MessageHandler,
            filters,
        )
    except ModuleNotFoundError as exc:  # pragma: no cover - environment specific
        TELEGRAM_IMPORT_ERROR = exc
        KeyboardButton = ReplyKeyboardMarkup = ReplyKeyboardRemove = Update = object  # type: ignore[assignment]
        Application = ApplicationBuilder = CommandHandler = ConversationHandler = MessageHandler = object  # type: ignore[assignment]
        ContextTypes = object  # type: ignore[assignment]
        filters = _MissingTelegramModule()  # type: ignore[assignment]
        _AIORateLimiter = None
    else:
        try:
            from telegram.ext import AIORateLimiter as _AIORateLimiter
        except ImportError:  # pragma: no cover - optional dependency
            _AIORateLimiter = None

AIORateLimiter = _AIORateLimiter


LOGGER = logging.getLogger(__name__)


ChatIdInput = Union[int, str]
AdminChatIdsInput = Union[ChatIdInput, Iterable[ChatIdInput], None]


def _require_telegram() -> None:
    """Ensure python-telegram-bot is installed before continuing."""

    if TELEGRAM_IMPORT_ERROR is not None:
        raise RuntimeError(_TELEGRAM_DEPENDENCY_INSTRUCTIONS) from TELEGRAM_IMPORT_ERROR


@dataclass
class MediaAttachment:
    """Representation of a media payload that can be resent later."""

    kind: str
    file_id: str
    caption: Optional[str] = None


@dataclass
class ContentBlock:
    """Rich content containing text and optional media attachments."""

    text: str = ""
    media: list[MediaAttachment] = field(default_factory=list)

    def copy(self) -> "ContentBlock":
        return ContentBlock(
            text=self.text,
            media=[MediaAttachment(kind=item.kind, file_id=item.file_id, caption=item.caption) for item in self.media],
        )


@dataclass
class BotContent:
    """Mutable content blocks that administrators can edit at runtime."""

    schedule: ContentBlock
    about: ContentBlock
    teachers: ContentBlock
    payment: ContentBlock
    album: ContentBlock
    contacts: ContentBlock
    vocabulary: list[dict[str, str]]

    @classmethod
    def default(cls) -> "BotContent":
        return cls(
            schedule=ContentBlock(
                text=(
                    "üá´üá∑ Voici nos horaires actuels :\n"
                    "üá∑üá∫ –ù–∞—à–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:\n\n"
                    "‚òÄÔ∏è Matin / –£—Ç—Ä–æ : 10:00 ‚Äì 12:00\n"
                    "üå§ Apr√®s-midi / –î–µ–Ω—å : 14:00 ‚Äì 16:00\n"
                    "üåô Soir / –í–µ—á–µ—Ä : 18:00 ‚Äì 20:00"
                )
            ),
            about=ContentBlock(
                text=(
                    "üá´üá∑ √Ä propos de nous\n"
                    "Notre compagnie existe d√©j√† depuis 8 ans, et pendant ce temps elle est devenue un lieu o√π les enfants d√©couvrent toute la beaut√© de la langue et de la culture fran√ßaises.\n"
                    "Notre √©quipe est compos√©e uniquement de professionnels :\n"
                    "‚Ä¢ des enseignants avec une formation sup√©rieure sp√©cialis√©e et des dipl√¥mes avec mention,\n"
                    "‚Ä¢ des titulaires du certificat international DALF,\n"
                "‚Ä¢ des professeurs avec plus de 10 ans d‚Äôexp√©rience,\n"
                "‚Ä¢ ainsi que des locuteurs natifs qui partagent l‚Äôauthenticit√© de la culture fran√ßaise.\n"
                "Chaque ann√©e, nous participons √† des festivals francophones dans toute la Russie ‚Äî de Moscou et Saint-P√©tersbourg √† Ekaterinbourg et Valda√Ø. Nous nous produisons r√©guli√®rement sur les sc√®nes de notre ville (par exemple √† l‚Äô√©cole n¬∞ 22), nous organisons des f√™tes populaires en France, et nous cl√¥turons chaque saison par un √©v√©nement festif attendu par tous nos √©l√®ves.\n"
                "Notre objectif principal est simple mais essentiel : üëâ que les enfants tombent amoureux du fran√ßais ‚ù§Ô∏è\n\n"
                "üá∑üá∫ –û –Ω–∞—Å\n"
                "–ù–∞—à–∞ —Å—Ç—É–¥–∏—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —É–∂–µ 8 –ª–µ—Ç, –∏ –∑–∞ —ç—Ç–æ –≤—Ä–µ–º—è –æ–Ω–∞ —Å—Ç–∞–ª–∞ –º–µ—Å—Ç–æ–º, –≥–¥–µ –¥–µ—Ç–∏ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç –¥–ª—è —Å–µ–±—è –∫—Ä–∞—Å–æ—Ç—É —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–≥–æ —è–∑—ã–∫–∞ –∏ –∫—É–ª—å—Ç—É—Ä—ã.\n"
                "–° –Ω–∞–º–∏ —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—ã:\n"
                "‚Ä¢ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏ —Å –≤—ã—Å—à–∏–º –ø—Ä–æ—Ñ–∏–ª—å–Ω—ã–º –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º –∏ –∫—Ä–∞—Å–Ω—ã–º–∏ –¥–∏–ø–ª–æ–º–∞–º–∏,\n"
                "‚Ä¢ –æ–±–ª–∞–¥–∞—Ç–µ–ª–∏ –º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω–æ–≥–æ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ DALF,\n"
                "‚Ä¢ –ø–µ–¥–∞–≥–æ–≥–∏ —Å–æ —Å—Ç–∞–∂–µ–º –±–æ–ª–µ–µ 10 –ª–µ—Ç,\n"
                "‚Ä¢ –∞ —Ç–∞–∫–∂–µ –Ω–æ—Å–∏—Ç–µ–ª–∏ —è–∑—ã–∫–∞, –∫–æ—Ç–æ—Ä—ã–µ –¥–µ–ª—è—Ç—Å—è –∞—É—Ç–µ–Ω—Ç–∏—á–Ω—ã–º —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–º –æ–ø—ã—Ç–æ–º.\n"
                "–ö–∞–∂–¥—ã–π –≥–æ–¥ –º—ã —É—á–∞—Å—Ç–≤—É–µ–º –≤–æ —Ñ—Ä–∞–Ω–∫–æ—Ñ–æ–Ω–Ω—ã—Ö —Ñ–µ—Å—Ç–∏–≤–∞–ª—è—Ö –ø–æ –≤—Å–µ–π –†–æ—Å—Å–∏–∏ ‚Äî –æ—Ç –ú–æ—Å–∫–≤—ã –∏ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–∞ –¥–æ –ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥–∞ –∏ –í–∞–ª–¥–∞—è. –ú—ã —Ä–µ–≥—É–ª—è—Ä–Ω–æ –≤—ã—Å—Ç—É–ø–∞–µ–º –Ω–∞ –ø–ª–æ—â–∞–¥–∫–∞—Ö –≥–æ—Ä–æ–¥–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ —à–∫–æ–ª–µ ‚Ññ 22), –æ—Ä–≥–∞–Ω–∏–∑—É–µ–º –ø—Ä–∞–∑–¥–Ω–∏–∫–∏, –ª—é–±–∏–º—ã–µ –≤–æ –§—Ä–∞–Ω—Ü–∏–∏, –∏ –¥–µ–ª–∞–µ–º —è—Ä–∫–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Å–µ–∑–æ–Ω–∞, –∫–æ—Ç–æ—Ä–æ–µ –∂–¥—É—Ç –≤—Å–µ –Ω–∞—à–∏ —É—á–µ–Ω–∏–∫–∏.\n"
                "–ù–∞—à–∞ –≥–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å –ø—Ä–æ—Å—Ç–∞ –∏ –æ—á–µ–Ω—å –≤–∞–∂–Ω–∞: üëâ —á—Ç–æ–±—ã –¥–µ—Ç–∏ –ø–æ–ª—é–±–∏–ª–∏ —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π —è–∑—ã–∫ ‚ù§Ô∏è\n\n"
                "üé≠ Chez nous, Confetti = f√™te !\nüé≠ –£ –Ω–∞—Å –ö–æ–Ω—Ñ–µ—Ç—Ç–∏ = —ç—Ç–æ –≤—Å–µ–≥–¥–∞ –ø—Ä–∞–∑–¥–Ω–∏–∫!"
                )
            ),
            teachers=ContentBlock(
                text=(
                    "üá´üá∑ Nos enseignants sont passionn√©s et exp√©riment√©s.\n"
                    "üá∑üá∫ –ù–∞—à–∏ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏ ‚Äî —É–≤–ª–µ—á—ë–Ω–Ω—ã–µ –∏ –æ–ø—ã—Ç–Ω—ã–µ –ø–µ–¥–∞–≥–æ–≥–∏.\n\n"
                    "üë©‚Äçüè´ Ksenia Nastytsch\n"
                    "Enseignante de fran√ßais avec plus de 20 ans d‚Äôexp√©rience.\n"
                    "Dipl√¥m√©e de l‚ÄôUniversit√© d‚Äô√âtat de Perm en philologie (fran√ßais, anglais, allemand et espagnol).\n"
                "Titulaire du certificat international DALF, a effectu√© des stages en France (Grenoble, Pau, Metz).\n\n"
                "–ö—Å–µ–Ω–∏—è –ù–∞—Å—Ç—ã—á\n"
                "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–≥–æ —è–∑—ã–∫–∞ —Å –æ–ø—ã—Ç–æ–º —Ä–∞–±–æ—Ç—ã –±–æ–ª–µ–µ 20 –ª–µ—Ç.\n"
                "–û–∫–æ–Ω—á–∏–ª–∞ –ü–µ—Ä–º—Å–∫–∏–π –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç –ø–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏ ¬´–§–∏–ª–æ–ª–æ–≥–∏—è¬ª.\n"
                "–û–±–ª–∞–¥–∞—Ç–µ–ª—å –º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω–æ–≥–æ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ DALF, –ø—Ä–æ—Ö–æ–¥–∏–ª–∞ —Å—Ç–∞–∂–∏—Ä–æ–≤–∫–∏ –≤–æ –§—Ä–∞–Ω—Ü–∏–∏ (–ì—Ä–µ–Ω–æ–±–ª—å, –ü–æ, –ú–µ—Ü). –û—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞–ª–∞ –≤ —Ç–µ—á–µ–Ω–∏–µ —Ç—Ä—ë—Ö –ª–µ—Ç ¬´—Ä—É—Å—Å–∫–∏–µ —Å–µ–∑–æ–Ω—ã¬ª –≤ –ü–æ—Å–æ–ª—å—Å—Ç–≤–µ –†–æ—Å—Å–∏–∏ –≤–æ –§—Ä–∞–Ω—Ü–∏–∏.\n\n"
                "üë©‚Äçüè´ –ê–Ω–∞—Å—Ç–∞—Å–∏—è –ë–∞–Ω–Ω–∏–∫–æ–≤–∞\n\n"
                "üá´üá∑ Alain Marinot\nLocuteur natif du fran√ßais avec un accent acad√©mique parisien. Acteur et √¢me de l‚Äô√©cole, il parle exclusivement en fran√ßais ‚Äî un grand avantage pour les √©l√®ves.\n\n"
                "üá∑üá∫ –ê–ª–µ–Ω –ú–∞—Ä–∏–Ω–æ\n–ù–æ—Å–∏—Ç–µ–ª—å —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–≥–æ —è–∑—ã–∫–∞ —Å –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–º –ø–∞—Ä–∏–∂—Å–∫–∏–º –∞–∫—Ü–µ–Ω—Ç–æ–º. –ê–∫—Ç—ë—Ä, –¥—É—à–∞ —à–∫–æ–ª—ã, –≥–æ–≤–æ—Ä–∏—Ç –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –ø–æ-—Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏ ‚Äî –±–æ–ª—å—à–∞—è —É–¥–∞—á–∞ –¥–ª—è —É—á–µ–Ω–∏–∫–æ–≤.\n\n"
                "üá´üá∑ Lyudmila Anatolievna Krasnoborova\nEnseignante de fran√ßais, docteur en philologie, ma√Ætresse de conf√©rences √† l‚ÄôUniversit√© d‚Äô√âtat de Perm (PGNIU).\n"
                "Examinateur DALF, pr√©pare aux examens du baccalaur√©at russe (–ï–ì–≠) et aux olympiades.\n\n"
                "üá∑üá∫ –ö—Ä–∞—Å–Ω–æ–±–æ—Ä–æ–≤–∞ –õ—é–¥–º–∏–ª–∞ –ê–Ω–∞—Ç–æ–ª—å–µ–≤–Ω–∞\n–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–≥–æ —è–∑—ã–∫–∞, –∫–∞–Ω–¥–∏–¥–∞—Ç —Ñ–∏–ª–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –Ω–∞—É–∫, –¥–æ—Ü–µ–Ω—Ç –ü–ì–ù–ò–£.\n"
                "–≠–∫–∑–∞–º–µ–Ω–∞—Ç–æ—Ä DALF, –≥–æ—Ç–æ–≤–∏—Ç –∫ –ï–ì–≠ –∏ –æ–ª–∏–º–ø–∏–∞–¥–∞–º."
                )
            ),
            payment=ContentBlock(
                text=(
                    "üá´üá∑ Veuillez envoyer une photo ou un re√ßu de paiement ici.\n"
                    "üá∑üá∫ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—é–¥–∞ —Ñ–æ—Ç–æ –∏–ª–∏ —á–µ–∫ –æ–± –æ–ø–ª–∞—Ç–µ.\n\n"
                    "üìå Apr√®s v√©rification, nous confirmerons votre inscription.\n"
                    "üìå –ü–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –º—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–º –≤–∞—à—É –∑–∞–ø–∏—Å—å."
                )
            ),
            album=ContentBlock(
                text=(
                    "üá´üá∑ Regardez nos meilleurs moments üé≠\n"
                    "üá∑üá∫ –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞—à–∏ –ª—É—á—à–∏–µ –º–æ–º–µ–Ω—Ç—ã üé≠\n\n"
                    "üëâ https://confetti.ru/album"
                )
            ),
            contacts=ContentBlock(
                text=(
                    "üìû T√©l√©phone : +7 (900) 000-00-00\n"
                    "üìß Email : confetti@example.com\n"
                    "üåê Site / –°–∞–π—Ç : https://confetti.ru\n"
                    "üì≤ Telegram : @ConfettiAdmin"
                )
            ),
            vocabulary=[
                {
                    "word": "Soleil",
                    "emoji": "‚òÄÔ∏è",
                    "translation": "–°–æ–ª–Ω—Ü–µ",
                    "example_fr": "Le soleil brille.",
                    "example_ru": "–°–æ–ª–Ω—Ü–µ —Å–≤–µ—Ç–∏—Ç.",
                },
                {
                    "word": "Bonjour",
                    "emoji": "üëã",
                    "translation": "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ",
                    "example_fr": "Bonjour, comment √ßa va ?",
                    "example_ru": "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, –∫–∞–∫ –¥–µ–ª–∞?",
                },
                {
                    "word": "Amiti√©",
                    "emoji": "ü§ù",
                    "translation": "–î—Ä—É–∂–±–∞",
                    "example_fr": "L'amiti√© rend la vie plus douce.",
                    "example_ru": "–î—Ä—É–∂–±–∞ –¥–µ–ª–∞–µ—Ç –∂–∏–∑–Ω—å –¥–æ–±—Ä–µ–µ.",
                },
                {
                    "word": "√âtoile",
                    "emoji": "‚ú®",
                    "translation": "–ó–≤–µ–∑–¥–∞",
                    "example_fr": "Chaque √©toile brille √† sa mani√®re.",
                    "example_ru": "–ö–∞–∂–¥–∞—è –∑–≤–µ–∑–¥–∞ —Å–∏—è–µ—Ç –ø–æ-—Å–≤–æ–µ–º—É.",
                },
            ],
        )

    def copy(self) -> "BotContent":
        return BotContent(
            schedule=self.schedule.copy(),
            about=self.about.copy(),
            teachers=self.teachers.copy(),
            payment=self.payment.copy(),
            album=self.album.copy(),
            contacts=self.contacts.copy(),
            vocabulary=[entry.copy() for entry in self.vocabulary],
        )


@dataclass
class ConfettiTelegramBot:
    """Light-weight wrapper around the PTB application builder."""

    token: str
    admin_chat_ids: AdminChatIdsInput = ()
    content_template: BotContent = field(default_factory=BotContent.default)

    REGISTRATION_PROGRAM = 1
    REGISTRATION_CHILD_NAME = 2
    REGISTRATION_CLASS = 3
    REGISTRATION_CONTACT_PERSON = 4
    REGISTRATION_PHONE = 5
    REGISTRATION_TIME = 6
    REGISTRATION_PAYMENT = 7

    CANCELLATION_PROGRAM = 21
    CANCELLATION_REASON = 22

    MAIN_MENU_BUTTON = "‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"
    REGISTRATION_BUTTON = "üìù –ó–∞–ø–∏—Å—å / Inscription"
    CANCELLATION_BUTTON = "‚ùóÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–Ω—è—Ç–∏–µ / Annuler"
    REGISTRATION_SKIP_PAYMENT_BUTTON = "‚è≠ –ü–æ–∫–∞ –±–µ–∑ –æ–ø–ª–∞—Ç—ã"
    ADMIN_MENU_BUTTON = "üõ† –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"
    ADMIN_BACK_TO_USER_BUTTON = "‚¨ÖÔ∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –º–µ–Ω—é"
    ADMIN_BROADCAST_BUTTON = "üì£ –†–∞—Å—Å—ã–ª–∫–∞"
    ADMIN_EXPORT_TABLE_BUTTON = "üìä –¢–∞–±–ª–∏—Ü–∞ –∑–∞—è–≤–æ–∫"
    ADMIN_ADD_ADMIN_BUTTON = "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞"
    ADMIN_EDIT_SCHEDULE_BUTTON = "üóì –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"
    ADMIN_EDIT_ABOUT_BUTTON = "‚ÑπÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é"
    ADMIN_EDIT_TEACHERS_BUTTON = "üë©‚Äçüè´ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π"
    ADMIN_EDIT_ALBUM_BUTTON = "üì∏ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ–∞–ª—å–±–æ–º"
    ADMIN_EDIT_CONTACTS_BUTTON = "üìû –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç—ã"
    ADMIN_EDIT_VOCABULARY_BUTTON = "üìö –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–ª–æ–≤–∞—Ä—å"
    ADMIN_CANCEL_KEYWORDS = ("–æ—Ç–º–µ–Ω–∞", "annuler", "cancel")
    ADMIN_CANCEL_PROMPT = (
        "\n\n–ß—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å, –Ω–∞–ø–∏—à–∏—Ç–µ ¬´–û—Ç–º–µ–Ω–∞¬ª.\nPour annuler, envoyez ¬´Annuler¬ª."
    )

    MAIN_MENU_LAYOUT = (
        (REGISTRATION_BUTTON, "üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ / Horaires"),
        ("‚ÑπÔ∏è –û —Å—Ç—É–¥–∏–∏ / √Ä propos de nous", "üë©‚Äçüè´ –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏ / Enseignants"),
        ("üì∏ –§–æ—Ç–æ–∞–ª—å–±–æ–º / Album photo", "üìû –ö–æ–Ω—Ç–∞–∫—Ç—ã / Contact"),
        ("üìö –ü–æ–ª–µ–∑–Ω—ã–µ —Å–ª–æ–≤–∞ / Vocabulaire", CANCELLATION_BUTTON),
    )

    TIME_OF_DAY_OPTIONS = (
        "‚òÄÔ∏è –£—Ç—Ä–æ / Matin",
        "üå§ –î–µ–Ω—å / Apr√®s-midi",
        "üåô –í–µ—á–µ—Ä / Soir",
    )

    PROGRAMS = (
        {
            "label": "üìö fran√ßais au quotidien / —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π –∫–∞–∂–¥—ã–π –¥–µ–Ω—å",
            "audience": "–° 3 –ø–æ 11 –∫–ª–∞—Å—Å",
            "teacher": "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å - –ù–∞—Å—Ç—ã—á –ö—Å–µ–Ω–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞",
            "schedule": "–î–Ω–∏ –∑–∞–Ω—è—Ç–∏–π: –≤—Ç–æ—Ä–Ω–∏–∫ –∏–ª–∏ —á–µ—Ç–≤–µ—Ä–≥ –≤–µ—á–µ—Ä",
        },
        {
            "label": "üé≠ th√©√¢tre francophone / —Ç–µ–∞—Ç—Ä –Ω–∞ —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–º",
            "teacher": "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å - –ù–∞—Å—Ç—ã—á –ö—Å–µ–Ω–∏—è –í–∏–∫—Ç–æ—Ä–æ–≤–Ω–∞",
            "schedule": "–î–Ω–∏ –∑–∞–Ω—è—Ç–∏–π: –≤—Ç–æ—Ä–Ω–∏–∫ –∏–ª–∏ —á–µ—Ç–≤–µ—Ä–≥ –≤–µ—á–µ—Ä",
        },
        {
            "label": "üìö fran√ßais du dimanche / –≤–æ—Å–∫—Ä–µ—Å–Ω—ã–π —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π",
            "audience": "1-4 –∫–ª–∞—Å—Å",
            "teacher": "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å - –ë–∞–Ω–Ω–∏–∫–æ–≤–∞ –ê–Ω–∞—Å—Ç–∞—Å–∏—è –î–º–∏—Ç—Ä–∏–µ–≤–Ω–∞",
            "schedule": "–î–Ω–∏ –∑–∞–Ω—è—Ç–∏–π: –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ",
        },
        {
            "label": "üé≠ th√©√¢tre francophone / —Ç–µ–∞—Ç—Ä –Ω–∞ —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–º (–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ)",
            "teacher": "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å - –ë–∞–Ω–Ω–∏–∫–æ–≤–∞ –ê–Ω–∞—Å—Ç–∞—Å–∏—è –î–º–∏—Ç—Ä–∏–µ–≤–Ω–∞",
            "schedule": "–î–Ω–∏ –∑–∞–Ω—è—Ç–∏–π: –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ",
        },
        {
            "label": "üá´üá∑ Fran√ßais au s√©rieux / –§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π –ø–æ-–≤–∑—Ä–æ—Å–ª–æ–º—É",
            "audience": "–ì—Ä—É–ø–ø–∞ –¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö (–ø—Ä–æ–¥–æ–ª–∂–∞—é—â–∏–µ)",
            "teacher": "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å - –ö—Ä–∞—Å–Ω–æ–±–æ—Ä–æ–≤–∞ –õ—é–¥–º–∏–ª–∞ –ê–Ω–∞—Ç–æ–ª—å–µ–≤–Ω–∞",
            "schedule": "–î–Ω–∏ –∑–∞–Ω—è—Ç–∏–π: –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ / —á–µ—Ç–≤–µ—Ä–≥ / –ø—è—Ç–Ω–∏—Ü–∞",
        },
        {
            "label": "üë©üèº‚Äçüè´ cours en individuel / –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –∑–∞–Ω—è—Ç–∏—è",
        },
        {
            "label": "üçÇ Stage d'automne / –æ—Å–µ–Ω–Ω–∏–π –∏–Ω—Ç–µ–Ω—Å–∏–≤",
        },
    )

    VOCABULARY = (
        {
            "word": "Soleil",
            "emoji": "‚òÄÔ∏è",
            "translation": "–°–æ–ª–Ω—Ü–µ",
            "example_fr": "Le soleil brille.",
            "example_ru": "–°–æ–ª–Ω—Ü–µ —Å–≤–µ—Ç–∏—Ç.",
        },
        {
            "word": "Bonjour",
            "emoji": "üëã",
            "translation": "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ",
            "example_fr": "Bonjour, comment √ßa va ?",
            "example_ru": "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, –∫–∞–∫ –¥–µ–ª–∞?",
        },
        {
            "word": "Amiti√©",
            "emoji": "ü§ù",
            "translation": "–î—Ä—É–∂–±–∞",
            "example_fr": "L'amiti√© rend la vie plus douce.",
            "example_ru": "–î—Ä—É–∂–±–∞ –¥–µ–ª–∞–µ—Ç –∂–∏–∑–Ω—å –¥–æ–±—Ä–µ–µ.",
        },
        {
            "word": "√âtoile",
            "emoji": "‚ú®",
            "translation": "–ó–≤–µ–∑–¥–∞",
            "example_fr": "Chaque √©toile brille √† sa mani√®re.",
            "example_ru": "–ö–∞–∂–¥–∞—è –∑–≤–µ–∑–¥–∞ —Å–∏—è–µ—Ç –ø–æ-—Å–≤–æ–µ–º—É.",
        },
    )

    CONTENT_LABELS = {
        "schedule": "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ",
        "about": "–û —Å—Ç—É–¥–∏–∏",
        "teachers": "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏",
        "payment": "–û–ø–ª–∞—Ç–∞",
        "album": "–§–æ—Ç–æ–∞–ª—å–±–æ–º",
        "contacts": "–ö–æ–Ω—Ç–∞–∫—Ç—ã",
    }

    def build_application(self) -> Application:
        """Construct the PTB application."""

        _require_telegram()

        builder = ApplicationBuilder().token(self.token)

        limiter = self._build_rate_limiter()
        if limiter is not None:
            builder = builder.rate_limiter(limiter)

        application = builder.build()
        self._register_handlers(application)
        return application

    def __post_init__(self) -> None:
        normalised = _normalise_admin_chat_ids(self.admin_chat_ids)
        self.admin_chat_ids = normalised
        self._runtime_admin_ids: set[int] = set(normalised)
        self._admin_cancel_tokens: set[str] = {token.lower() for token in self.ADMIN_CANCEL_KEYWORDS}
        self._bot_username: Optional[str] = None

    def build_profile(self, chat: Any, user: Any | None = None) -> "UserProfile":
        """Return the appropriate profile for ``chat`` and optional ``user``."""

        chat_id = _coerce_chat_id_from_object(chat)
        if self._is_admin_identity(chat=chat, user=user):
            return AdminProfile(chat_id=chat_id)
        return UserProfile(chat_id=chat_id)

    def is_admin_chat(self, chat: Any) -> bool:
        """Return ``True`` when ``chat`` belongs to an administrator."""

        return self._is_admin_identity(chat=chat)

    def is_admin_user(self, user: Any) -> bool:
        """Return ``True`` when ``user`` is recognised as an administrator."""

        return self._is_admin_identity(user=user)

    def _build_rate_limiter(self) -> Optional[AIORateLimiter]:  # type: ignore[name-defined]
        """Return an ``AIORateLimiter`` instance when possible."""

        if AIORateLimiter is None:
            LOGGER.warning(
                "python-telegram-bot was installed without the optional rate limiter extras. "
                "The bot will run without a rate limiter."
            )
            return None

        try:
            return AIORateLimiter()
        except RuntimeError as exc:  # pragma: no cover - depends on installation
            LOGGER.warning(
                "Failed to initialise the AIORateLimiter: %s. Running without a rate limiter.",
                exc,
            )
            return None

    # ------------------------------------------------------------------
    # Handler registration helpers

    def _register_handlers(self, application: Application) -> None:
        """Attach all command and message handlers to ``application``."""

        conversation = ConversationHandler(
            entry_points=[
                MessageHandler(
                    filters.Regex(self._exact_match_regex(self.REGISTRATION_BUTTON)),
                    self._start_registration,
                )
            ],
            states={
                self.REGISTRATION_PROGRAM: [
                    MessageHandler(
                        filters.Regex(self._programs_regex()),
                        self._registration_collect_program,
                    ),
                    MessageHandler(
                        filters.Regex(self._exact_match_regex(self.MAIN_MENU_BUTTON)),
                        self._registration_cancel,
                    ),
                ],
                self.REGISTRATION_CHILD_NAME: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._registration_collect_child_name),
                ],
                self.REGISTRATION_CLASS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._registration_collect_class),
                ],
                self.REGISTRATION_CONTACT_PERSON: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._registration_collect_contact_person),
                ],
                self.REGISTRATION_PHONE: [
                    MessageHandler(filters.CONTACT, self._registration_collect_phone_contact),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._registration_collect_phone_text),
                ],
                self.REGISTRATION_TIME: [
                    MessageHandler(
                        filters.Regex(self._time_regex()),
                        self._registration_collect_time,
                    ),
                    MessageHandler(
                        filters.Regex(self._exact_match_regex(self.MAIN_MENU_BUTTON)),
                        self._registration_cancel,
                    ),
                ],
                self.REGISTRATION_PAYMENT: [
                    MessageHandler(~filters.COMMAND, self._registration_collect_payment),
                ],
            },
            fallbacks=[
                CommandHandler("cancel", self._registration_cancel),
                MessageHandler(
                    filters.Regex(self._exact_match_regex(self.MAIN_MENU_BUTTON)),
                    self._registration_cancel,
                ),
            ],
            allow_reentry=True,
        )

        cancellation = ConversationHandler(
            entry_points=[
                MessageHandler(
                    filters.Regex(self._exact_match_regex(self.CANCELLATION_BUTTON)),
                    self._start_cancellation,
                )
            ],
            states={
                self.CANCELLATION_PROGRAM: [
                    MessageHandler(
                        filters.Regex(self._programs_regex()),
                        self._cancellation_collect_program,
                    ),
                    MessageHandler(
                        filters.Regex(self._exact_match_regex(self.MAIN_MENU_BUTTON)),
                        self._cancellation_cancel,
                    ),
                ],
                self.CANCELLATION_REASON: [
                    MessageHandler(~filters.COMMAND, self._cancellation_collect_reason),
                ],
            },
            fallbacks=[
                CommandHandler("cancel", self._cancellation_cancel),
                MessageHandler(
                    filters.Regex(self._exact_match_regex(self.MAIN_MENU_BUTTON)),
                    self._cancellation_cancel,
                ),
            ],
            allow_reentry=True,
        )

        application.add_handler(CommandHandler("start", self._start))
        application.add_handler(CommandHandler("menu", self._show_main_menu))
        application.add_handler(CommandHandler("admin", self._show_admin_menu))
        application.add_handler(conversation)
        application.add_handler(cancellation)
        application.add_handler(MessageHandler(~filters.COMMAND, self._handle_message))

    def _exact_match_regex(self, text: str) -> str:
        return rf"^{re.escape(text)}$"

    def _programs_regex(self) -> str:
        parts = [re.escape(program["label"]) for program in self.PROGRAMS]
        return rf"^({'|'.join(parts)})$"

    def _time_regex(self) -> str:
        parts = [re.escape(option) for option in self.TIME_OF_DAY_OPTIONS]
        return rf"^({'|'.join(parts)})$"

    # ------------------------------------------------------------------
    # Shared messaging helpers

    def _main_menu_markup(self, *, include_admin: bool = False) -> ReplyKeyboardMarkup:
        keyboard = [list(row) for row in self.MAIN_MENU_LAYOUT]
        if include_admin:
            keyboard.append([self.ADMIN_MENU_BUTTON])
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    def _main_menu_markup_for(
        self, update: Update, context: Optional[ContextTypes.DEFAULT_TYPE] = None
    ) -> ReplyKeyboardMarkup:
        return self._main_menu_markup(include_admin=self._is_admin_update(update, context))

    def _admin_menu_markup(self) -> ReplyKeyboardMarkup:
        keyboard = [
            [self.ADMIN_BACK_TO_USER_BUTTON],
            [self.ADMIN_BROADCAST_BUTTON, self.ADMIN_EXPORT_TABLE_BUTTON],
            [self.ADMIN_ADD_ADMIN_BUTTON],
            [self.ADMIN_EDIT_SCHEDULE_BUTTON],
            [self.ADMIN_EDIT_ABOUT_BUTTON],
            [self.ADMIN_EDIT_TEACHERS_BUTTON],
            [self.ADMIN_EDIT_ALBUM_BUTTON],
            [self.ADMIN_EDIT_CONTACTS_BUTTON],
            [self.ADMIN_EDIT_VOCABULARY_BUTTON],
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    def _is_admin_identity(self, *, chat: Any | None = None, user: Any | None = None) -> bool:
        """Check whether either ``chat`` or ``user`` matches an admin id."""

        for candidate in (chat, user):
            if candidate is None:
                continue
            try:
                candidate_id = _coerce_chat_id_from_object(candidate)
            except ValueError:
                continue
            if candidate_id in self._runtime_admin_ids:
                return True
        return False

    def _is_admin_update(
        self, update: Update, context: Optional[ContextTypes.DEFAULT_TYPE] = None
    ) -> bool:
        if context is not None:
            self._refresh_admin_cache(context)
        return self._is_admin_identity(chat=update.effective_chat, user=update.effective_user)

    def _application_data(self, context: ContextTypes.DEFAULT_TYPE) -> dict[str, Any]:
        """Return application-level storage across PTB versions."""

        if hasattr(context, "application_data"):
            return context.application_data  # type: ignore[attr-defined]

        if hasattr(context, "bot_data"):
            return context.bot_data  # type: ignore[attr-defined]

        application = getattr(context, "application", None)
        if application is not None and hasattr(application, "bot_data"):
            return application.bot_data  # type: ignore[attr-defined]

        # Fallback to a dedicated attribute to avoid repeated lookups if nothing matches.
        storage = getattr(context, "_fallback_application_data", None)
        if isinstance(storage, dict):
            return storage

        storage = {}
        setattr(context, "_fallback_application_data", storage)
        return storage

    def _refresh_admin_cache(self, context: ContextTypes.DEFAULT_TYPE) -> set[int]:
        """Load dynamic administrators from storage into the runtime cache."""

        storage = self._application_data(context)
        candidates = storage.get("dynamic_admins")
        ids: set[int] = set()
        if isinstance(candidates, (set, list, tuple)):
            for candidate in candidates:
                try:
                    ids.add(_coerce_chat_id(candidate))
                except ValueError:
                    continue
        storage["dynamic_admins"] = ids
        self._runtime_admin_ids.update(ids)
        return ids

    def _store_dynamic_admin(
        self, context: ContextTypes.DEFAULT_TYPE, admin_id: int
    ) -> set[int]:
        storage = self._application_data(context)
        existing = storage.get("dynamic_admins")
        if not isinstance(existing, set):
            existing = self._refresh_admin_cache(context)
        existing.add(admin_id)
        storage["dynamic_admins"] = existing
        self._runtime_admin_ids.add(admin_id)
        return existing

    def _remember_chat(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        self._refresh_admin_cache(context)
        chat = update.effective_chat
        if not chat:
            return
        known = self._get_known_chats(context)
        known.add(_coerce_chat_id_from_object(chat))

    def _get_known_chats(self, context: ContextTypes.DEFAULT_TYPE) -> set[int]:
        store = self._application_data(context).setdefault("known_chats", set())
        if isinstance(store, set):
            return store
        if isinstance(store, list):
            converted: set[int] = set()
            for chat_id in store:
                try:
                    converted.add(_coerce_chat_id(chat_id))
                except ValueError:
                    continue
            self._application_data(context)["known_chats"] = converted
            return converted
        converted: set[int] = set()
        self._application_data(context)["known_chats"] = converted
        return converted

    def _get_content(self, context: ContextTypes.DEFAULT_TYPE) -> BotContent:
        content = self._application_data(context).get("content")
        if isinstance(content, BotContent):
            for field_name in self.CONTENT_LABELS:
                block = getattr(content, field_name, None)
                if isinstance(block, str):
                    setattr(content, field_name, ContentBlock(text=block))
            return content
        if isinstance(content, dict):
            # Backward compatibility if someone serialised a dict previously.
            restored = self.content_template.copy()
            self._application_data(context)["content"] = restored
            return restored
        fresh = self.content_template.copy()
        self._application_data(context)["content"] = fresh
        return fresh

    def _store_registration(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        data: dict[str, Any],
        attachments: Optional[list[MediaAttachment]] = None,
    ) -> None:
        chat = update.effective_chat
        user = update.effective_user
        record = {
            "program": data.get("program", ""),
            "child_name": data.get("child_name", ""),
            "class": data.get("class", ""),
            "contact_person": data.get("contact_person", ""),
            "phone": data.get("phone", ""),
            "time": data.get("time", ""),
            "chat_id": _coerce_chat_id_from_object(chat) if chat else None,
            "chat_title": getattr(chat, "title", None) if chat else None,
            "submitted_by": getattr(user, "full_name", None) if user else None,
            "submitted_by_id": getattr(user, "id", None) if user else None,
            "created_at": datetime.utcnow().strftime("%Y-%m-%d %H:%M"),
            "payment_note": data.get("payment_note", ""),
            "payment_media": self._attachments_to_dicts(attachments or [])
            if attachments
            else data.get("payment_media", []),
        }
        registrations = self._application_data(context).setdefault("registrations", [])
        if isinstance(registrations, list):
            registrations.append(record)
        else:
            self._application_data(context)["registrations"] = [record]

    async def _store_cancellation(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        data: dict[str, Any],
        attachments: Optional[list[MediaAttachment]] = None,
    ) -> None:
        chat = update.effective_chat
        user = update.effective_user
        record = {
            "program": data.get("program", ""),
            "details": data.get("details", ""),
            "chat_id": _coerce_chat_id_from_object(chat) if chat else None,
            "submitted_by": getattr(user, "full_name", None) if user else None,
            "submitted_by_id": getattr(user, "id", None) if user else None,
            "created_at": datetime.utcnow().strftime("%Y-%m-%d %H:%M"),
            "attachments": self._attachments_to_dicts(attachments or [])
            if attachments
            else data.get("evidence", []),
        }
        storage = self._application_data(context).setdefault("cancellations", [])
        if isinstance(storage, list):
            storage.append(record)
        else:
            self._application_data(context)["cancellations"] = [record]

        admin_message = (
            "üö´ –û—Ç–º–µ–Ω–∞ –∑–∞–Ω—è—Ç–∏—è\n"
            f"üìö –ü—Ä–æ–≥—Ä–∞–º–º–∞: {record.get('program', '‚Äî')}\n"
            f"üìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {record.get('details', '‚Äî')}\n"
            f"üë§ –û—Ç–ø—Ä–∞–≤–∏–ª: {record.get('submitted_by', '‚Äî')}"
        )
        await self._notify_admins(
            context,
            admin_message,
            media=self._dicts_to_attachments(record.get("attachments")),
        )
        context.user_data.pop("cancellation", None)

    async def _start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send the greeting and display the main menu."""

        self._remember_chat(update, context)

        args = context.args if context.args is not None else []
        if args:
            payload = args[0]
            if payload == "registrations_excel":
                if not self._is_admin_update(update, context):
                    await self._reply(
                        update,
                        "–≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.\n"
                        "Section r√©serv√©e aux administrateurs.",
                        reply_markup=self._main_menu_markup_for(update, context),
                    )
                    return
                sent = await self._send_registrations_excel(update, context)
                if sent:
                    await self._reply(
                        update,
                        "–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω. –¢–∞–±–ª–∏—Ü–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ–º –≤—ã—à–µ.\n"
                        "Le tableau vient d'√™tre envoy√© dans cette conversation.",
                        reply_markup=self._admin_menu_markup(),
                    )
                return

        await self._send_greeting(update, context)

    async def _show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Show the menu without repeating the full greeting."""

        self._remember_chat(update, context)
        message = (
            "üëâ Veuillez choisir une rubrique dans le menu ci-dessous.\n"
            "üëâ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –≤ –º–µ–Ω—é –Ω–∏–∂–µ."
        )
        if self._is_admin_update(update, context):
            message += (
                "\n\nüõ† –î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º –æ—Ç–∫—Ä–æ–π—Ç–µ ¬´–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å¬ª –≤ –º–µ–Ω—é."
                "\nüõ† Pour administrer le bot, choisissez ¬´–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å¬ª."
            )
        await self._reply(update, message, reply_markup=self._main_menu_markup_for(update, context))

    async def _show_admin_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not self._is_admin_update(update, context):
            await self._reply(
                update,
                "–≠—Ç–∞ –ø–∞–Ω–µ–ª—å –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.\n"
                "Ce panneau est r√©serv√© aux administrateurs.",
                reply_markup=self._main_menu_markup_for(update, context),
            )
            return
        self._remember_chat(update, context)
        message = (
            "–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –æ—Ç–∫—Ä—ã—Ç–∞. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ.\n"
            "Panneau d'administration ouvert ‚Äî choisissez une action."
        )
        await self._reply(update, message, reply_markup=self._admin_menu_markup())

    async def _send_greeting(self, update: Update, context: Optional[ContextTypes.DEFAULT_TYPE] = None) -> None:
        greeting = (
            "üéâ üá´üá∑ Bonjour et bienvenue dans la compagnie ¬´Confetti¬ª !\n"
            "üéâ üá∑üá∫ –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ –∏ –¥–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å—Ç—É–¥–∏—é ¬´–ö–æ–Ω—Ñ–µ—Ç—Ç–∏¬ª!\n\n"
            "Nous adorons la France et le fran√ßais ‚Äî et nous sommes pr√™ts √† partager cet amour √† chacun.\n\n"
            "–ú—ã –æ–±–æ–∂–∞–µ–º –§—Ä–∞–Ω—Ü–∏—é –∏ —Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π ‚Äî –∏ –≥–æ—Ç–æ–≤—ã –¥–µ–ª–∏—Ç—å—Å—è —ç—Ç–æ–π –ª—é–±–æ–≤—å—é —Å –∫–∞–∂–¥—ã–º.\n\n"
            "üëâ Veuillez choisir une rubrique dans le menu ci-dessous.\n"
            "üëâ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –≤ –º–µ–Ω—é –Ω–∏–∂–µ."
        )
        if self._is_admin_update(update, context):
            greeting += (
                "\n\nüõ† –£ –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ ‚Äî –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã —É–ø—Ä–∞–≤–ª—è—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º."
                "\nüõ† Vous pouvez g√©rer le contenu via le bouton ¬´–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å¬ª."
            )
        await self._reply(update, greeting, reply_markup=self._main_menu_markup_for(update, context))

    async def _reply(
        self,
        update: Update,
        text: Optional[str] = None,
        *,
        reply_markup: Optional[ReplyKeyboardMarkup | ReplyKeyboardRemove] = None,
        media: Optional[list[MediaAttachment]] = None,
    ) -> None:
        message = update.message
        callback = update.callback_query
        target = message or (callback.message if callback else None)

        if callback:
            await callback.answer()

        markup_used = False

        if text:
            if target is not None:
                await target.reply_text(text, reply_markup=reply_markup)
                markup_used = True
        if media and target is not None:
            for index, attachment in enumerate(media):
                extra: dict[str, Any] = {}
                if not markup_used and reply_markup is not None and index == 0:
                    extra["reply_markup"] = reply_markup
                    markup_used = True
                if attachment.caption:
                    extra["caption"] = attachment.caption
                try:
                    if attachment.kind == "photo":
                        await target.reply_photo(attachment.file_id, **extra)
                    elif attachment.kind == "video":
                        await target.reply_video(attachment.file_id, **extra)
                    elif attachment.kind == "animation":
                        await target.reply_animation(attachment.file_id, **extra)
                    elif attachment.kind == "document":
                        await target.reply_document(attachment.file_id, **extra)
                    elif attachment.kind == "video_note":
                        await target.reply_video_note(attachment.file_id)
                    else:
                        LOGGER.debug("Unsupported media type %s", attachment.kind)
                except Exception as exc:  # pragma: no cover - network dependent
                    LOGGER.warning("Failed to reply with media %s: %s", attachment.kind, exc)
        elif reply_markup is not None and not markup_used and target is not None:
            await target.reply_text("", reply_markup=reply_markup)

    def _extract_message_payload(self, message: Any | None) -> tuple[str, list[MediaAttachment]]:
        """Return the plain text and media attachments contained in ``message``."""

        if message is None:
            return "", []

        text = (getattr(message, "text", None) or "").strip()
        caption = (getattr(message, "caption", None) or "").strip()
        remaining_caption = caption or None
        attachments: list[MediaAttachment] = []

        def push(kind: str, file_id: str) -> None:
            nonlocal remaining_caption
            attachments.append(
                MediaAttachment(kind=kind, file_id=file_id, caption=remaining_caption)
            )
            remaining_caption = None

        photos = getattr(message, "photo", None)
        if photos:
            try:
                best_photo = max(photos, key=lambda item: getattr(item, "file_size", 0) or 0)
            except ValueError:
                best_photo = photos[-1]
            push("photo", best_photo.file_id)

        video = getattr(message, "video", None)
        if video:
            push("video", video.file_id)

        animation = getattr(message, "animation", None)
        if animation:
            push("animation", animation.file_id)

        document = getattr(message, "document", None)
        if document:
            push("document", document.file_id)

        video_note = getattr(message, "video_note", None)
        if video_note:
            attachments.append(MediaAttachment(kind="video_note", file_id=video_note.file_id))

        return text, attachments

    async def _send_payload_to_chat(
        self,
        context: ContextTypes.DEFAULT_TYPE,
        chat_id: int,
        *,
        text: Optional[str] = None,
        media: Optional[list[MediaAttachment]] = None,
        reply_markup: Optional[ReplyKeyboardMarkup | ReplyKeyboardRemove] = None,
    ) -> None:
        if text:
            await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup)
            reply_markup = None
        if not media:
            return
        for index, attachment in enumerate(media):
            extra: dict[str, Any] = {}
            if attachment.caption:
                extra["caption"] = attachment.caption
            if reply_markup is not None and index == 0:
                extra["reply_markup"] = reply_markup
            try:
                if attachment.kind == "photo":
                    await context.bot.send_photo(chat_id=chat_id, photo=attachment.file_id, **extra)
                elif attachment.kind == "video":
                    await context.bot.send_video(chat_id=chat_id, video=attachment.file_id, **extra)
                elif attachment.kind == "animation":
                    await context.bot.send_animation(chat_id=chat_id, animation=attachment.file_id, **extra)
                elif attachment.kind == "document":
                    await context.bot.send_document(chat_id=chat_id, document=attachment.file_id, **extra)
                elif attachment.kind == "video_note":
                    await context.bot.send_video_note(chat_id=chat_id, video_note=attachment.file_id)
                else:
                    LOGGER.debug("Unsupported media type %s for broadcast", attachment.kind)
            except Exception as exc:  # pragma: no cover - network dependent
                LOGGER.warning("Failed to deliver media %s to %s: %s", attachment.kind, chat_id, exc)

    async def _notify_admins(
        self,
        context: ContextTypes.DEFAULT_TYPE,
        text: str,
        *,
        media: Optional[list[MediaAttachment]] = None,
    ) -> None:
        recipients = set(self._runtime_admin_ids)
        recipients.update(self._refresh_admin_cache(context))
        for admin_id in sorted(recipients):
            try:
                await self._send_payload_to_chat(context, admin_id, text=text, media=media)
            except Exception as exc:  # pragma: no cover - network dependent
                LOGGER.warning("Failed to notify admin %s: %s", admin_id, exc)

    def _attachments_to_dicts(self, attachments: list[MediaAttachment]) -> list[dict[str, str]]:
        serialised: list[dict[str, str]] = []
        for attachment in attachments:
            serialised.append(
                {
                    "kind": attachment.kind,
                    "file_id": attachment.file_id,
                    "caption": attachment.caption or "",
                }
            )
        return serialised

    def _dicts_to_attachments(self, payload: Any) -> list[MediaAttachment]:
        attachments: list[MediaAttachment] = []
        if not isinstance(payload, list):
            return attachments
        for entry in payload:
            if not isinstance(entry, dict):
                continue
            kind = entry.get("kind")
            file_id = entry.get("file_id")
            if not kind or not file_id:
                continue
            caption = entry.get("caption") or None
            attachments.append(MediaAttachment(kind=kind, file_id=file_id, caption=caption))
        return attachments

    # ------------------------------------------------------------------
    # Registration conversation

    async def _start_registration(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        self._remember_chat(update, context)
        context.user_data["registration"] = {}
        message_lines = [
            "üá´üá∑ √Ä quel programme souhaitez-vous inscrire votre enfant ou vous inscrire ?",
            "üá∑üá∫ –ù–∞ –∫–∞–∫—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É –≤—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø–∏—Å–∞—Ç—å —Ä–µ–±—ë–Ω–∫–∞ –∏–ª–∏ –∑–∞–ø–∏—Å–∞—Ç—å —Å–µ–±—è?",
        ]
        details = [self._format_program_details(program) for program in self.PROGRAMS]
        await self._reply(
            update,
            "\n".join(message_lines + details),
            reply_markup=self._program_keyboard(),
        )
        return self.REGISTRATION_PROGRAM

    def _program_keyboard(self) -> ReplyKeyboardMarkup:
        keyboard = [[program["label"]] for program in self.PROGRAMS]
        keyboard.append([self.MAIN_MENU_BUTTON])
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

    def _format_program_details(self, program: Dict[str, str]) -> str:
        parts = [program["label"]]
        for key in ("audience", "teacher", "schedule"):
            if value := program.get(key):
                parts.append(value)
        return "\n".join(parts)

    async def _registration_collect_program(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        program_label = update.message.text
        context.user_data.setdefault("registration", {})["program"] = program_label
        await self._reply(
            update,
            "Merci ! / –°–ø–∞—Å–∏–±–æ! –ù–∞–ø–∏—à–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é —Ä–µ–±—ë–Ω–∫–∞.",
            reply_markup=ReplyKeyboardRemove(),
        )
        return self.REGISTRATION_CHILD_NAME

    async def _registration_collect_child_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        context.user_data.setdefault("registration", {})["child_name"] = update.message.text.strip()
        await self._reply(
            update,
            "üá´üá∑ Indiquez la classe, s'il vous pla√Æt.\nüá∑üá∫ –£–∫–∞–∂–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∫–ª–∞—Å—Å.",
        )
        return self.REGISTRATION_CLASS

    async def _registration_collect_class(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        context.user_data.setdefault("registration", {})["class"] = update.message.text.strip()
        await self._reply(
            update,
            "üá´üá∑ Qui est la personne de contact ?\nüá∑üá∫ –ö—Ç–æ –±—É–¥–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç–Ω—ã–º –ª–∏—Ü–æ–º?",
        )
        return self.REGISTRATION_CONTACT_PERSON

    async def _registration_collect_contact_person(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        context.user_data.setdefault("registration", {})["contact_person"] = update.message.text.strip()
        await self._reply(
            update,
            "üá´üá∑ Envoyez le num√©ro de t√©l√©phone (bouton en bas).\n"
            "üá∑üá∫ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–∫–Ω–æ–ø–∫–∞ –≤–Ω–∏–∑—É).",
            reply_markup=self._phone_keyboard(),
        )
        return self.REGISTRATION_PHONE

    def _phone_keyboard(self) -> ReplyKeyboardMarkup:
        keyboard = [
            [KeyboardButton("üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä", request_contact=True)],
            [KeyboardButton(self.MAIN_MENU_BUTTON)],
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

    def _payment_keyboard(self) -> ReplyKeyboardMarkup:
        keyboard = [
            [KeyboardButton(self.REGISTRATION_SKIP_PAYMENT_BUTTON)],
            [KeyboardButton(self.MAIN_MENU_BUTTON)],
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

    async def _registration_collect_phone_contact(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        phone_number = update.message.contact.phone_number
        context.user_data.setdefault("registration", {})["phone"] = phone_number
        return await self._prompt_time_of_day(update)

    async def _registration_collect_phone_text(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        text = update.message.text.strip()
        if text == self.MAIN_MENU_BUTTON:
            return await self._registration_cancel(update, context)
        context.user_data.setdefault("registration", {})["phone"] = text
        return await self._prompt_time_of_day(update)

    async def _prompt_time_of_day(self, update: Update) -> int:
        await self._reply(
            update,
            "üá´üá∑ Choisissez le moment qui vous convient.\n"
            "üá∑üá∫ –í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–Ω—è—Ç–∏–π.",
            reply_markup=self._time_keyboard(),
        )
        return self.REGISTRATION_TIME

    def _time_keyboard(self) -> ReplyKeyboardMarkup:
        keyboard = [[option] for option in self.TIME_OF_DAY_OPTIONS]
        keyboard.append([self.MAIN_MENU_BUTTON])
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)

    async def _registration_collect_time(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        context.user_data.setdefault("registration", {})["time"] = update.message.text.strip()
        return await self._prompt_payment_request(update, context)

    async def _prompt_payment_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        instructions = self._get_content(context).payment
        message = (
            "üí≥ üá´üá∑ Envoyez une confirmation du paiement (photo, vid√©o ou fichier).\n"
            "üí≥ üá∑üá∫ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–ø–ª–∞—Ç—ã (—Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ –∏–ª–∏ —Ñ–∞–π–ª).\n\n"
            "‚û°Ô∏è –ï—Å–ª–∏ –æ–ø–ª–∞—Ç—ã –µ—â—ë –Ω–µ—Ç, –Ω–∞–∂–º–∏—Ç–µ ¬´‚è≠ –ü–æ–∫–∞ –±–µ–∑ –æ–ø–ª–∞—Ç—ã¬ª –∏ –º—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –ø–æ–∑–∂–µ."
        )
        if instructions.text:
            message += "\n\n" + instructions.text
        await self._reply(
            update,
            message,
            reply_markup=self._payment_keyboard(),
            media=instructions.media or None,
        )
        return self.REGISTRATION_PAYMENT

    async def _registration_collect_payment(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        data = context.user_data.setdefault("registration", {})
        text, attachments = self._extract_message_payload(update.message)

        if text == self.MAIN_MENU_BUTTON:
            return await self._registration_cancel(update, context)

        if text == self.REGISTRATION_SKIP_PAYMENT_BUTTON:
            data["payment_note"] = "–ü–ª–∞—Ç—ë–∂ –±—É–¥–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω –ø–æ–∑–∂–µ"
            data.pop("payment_media", None)
            await self._send_registration_summary(update, context, media=None)
            await self._show_main_menu(update, context)
            return ConversationHandler.END

        if attachments:
            data["payment_media"] = self._attachments_to_dicts(attachments)
        if text:
            data["payment_note"] = text

        await self._send_registration_summary(update, context, media=attachments or None)
        await self._show_main_menu(update, context)
        return ConversationHandler.END

    async def _registration_cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        context.user_data.pop("registration", None)
        await self._reply(
            update,
            "‚ùå –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n‚ùå L'inscription est annul√©e.",
            reply_markup=self._main_menu_markup_for(update, context),
        )
        return ConversationHandler.END

    # ------------------------------------------------------------------
    # Cancellation conversation

    async def _start_cancellation(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        self._remember_chat(update, context)
        context.user_data["cancellation"] = {}
        message = (
            "‚ùóÔ∏è üá´üá∑ Indiquez la s√©ance que vous annulez.\n"
            "‚ùóÔ∏è üá∑üá∫ –£–∫–∞–∂–∏—Ç–µ –∑–∞–Ω—è—Ç–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç–µ.\n\n"
            "‚ö†Ô∏è –û–ø–ª–∞—Ç–∞ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è ‚Äî —Å—Ä–µ–¥—Å—Ç–≤–∞ –æ—Å—Ç–∞—é—Ç—Å—è –Ω–∞ –±–∞–ª–∞–Ω—Å–µ —Å—Ç—É–¥–∏–∏."
        )
        await self._reply(update, message, reply_markup=self._program_keyboard())
        return self.CANCELLATION_PROGRAM

    async def _cancellation_collect_program(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        context.user_data.setdefault("cancellation", {})["program"] = update.message.text.strip()
        await self._reply(
            update,
            "üìÖ –ù–∞–ø–∏—à–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –ø—Ä–æ–ø—É—Å–∫–∞, –∞ —Ç–∞–∫–∂–µ –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π.\n"
            "üìÖ Indiquez la date, l'heure et un commentaire, s'il vous pla√Æt.",
            reply_markup=ReplyKeyboardRemove(),
        )
        return self.CANCELLATION_REASON

    async def _cancellation_collect_reason(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> int:
        data = context.user_data.setdefault("cancellation", {})
        text, attachments = self._extract_message_payload(update.message)

        if text == self.MAIN_MENU_BUTTON:
            return await self._cancellation_cancel(update, context)

        if attachments:
            data["evidence"] = self._attachments_to_dicts(attachments)
        data["details"] = text or ""

        await self._store_cancellation(update, context, data, attachments or None)

        confirmation = (
            "‚úÖ –û—Ç–º–µ–Ω–∞ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞.\n"
            "‚ÑπÔ∏è –°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω–æ–µ –∑–∞–Ω—è—Ç–∏–µ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è, –Ω–æ –º—ã —É—á–ª–∏ –≤–∞—à –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π."
        )
        await self._reply(
            update,
            confirmation,
            reply_markup=self._main_menu_markup_for(update, context),
        )
        await self._show_main_menu(update, context)
        return ConversationHandler.END

    async def _cancellation_cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        context.user_data.pop("cancellation", None)
        await self._reply(
            update,
            "–û—Ç–º–µ–Ω–∞ –∑–∞–Ω—è—Ç–∏—è –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.\nAnnulation ignor√©e.",
            reply_markup=self._main_menu_markup_for(update, context),
        )
        return ConversationHandler.END

    async def _send_registration_summary(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        *,
        media: Optional[list[MediaAttachment]] = None,
    ) -> None:
        data = context.user_data.get("registration", {})
        attachments = media or self._dicts_to_attachments(data.get("payment_media"))
        payment_note = data.get("payment_note")
        payment_status = "‚úÖ Paiement re√ßu" if attachments else "‚è≥ Paiement en attente"
        payment_status_ru = "‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞" if attachments else "‚è≥ –û–ø–ª–∞—Ç–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è"

        summary = (
            "üá´üá∑ Votre demande a √©t√© enregistr√©e !\n"
            "üá∑üá∫ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞!\n\n"
            f"üë¶ Enfant : {data.get('child_name', '‚Äî')} ({data.get('class', '‚Äî')})\n"
            f"üë§ Contact : {data.get('contact_person', '‚Äî')}\n"
            f"üì± T√©l√©phone : {data.get('phone', '‚Äî')}\n"
            f"üïí Heure : {data.get('time', '‚Äî')}\n"
            f"üìö Programme : {data.get('program', '‚Äî')}\n"
            f"üí≥ {payment_status} | {payment_status_ru}\n"
        )
        if payment_note:
            summary += f"üìù Remarque : {payment_note}\n"
        summary += (
            "\nNous vous contacterons prochainement.\n"
            "–ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è."
        )

        await self._reply(update, summary, reply_markup=self._main_menu_markup_for(update, context))
        self._store_registration(update, context, data, attachments)

        admin_message = (
            "üÜï –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ / Nouvelle inscription\n"
            f"üìö –ü—Ä–æ–≥—Ä–∞–º–º–∞: {data.get('program', '‚Äî')}\n"
            f"üë¶ –£—á–∞—Å—Ç–Ω–∏–∫: {data.get('child_name', '‚Äî')} ({data.get('class', '‚Äî')})\n"
            f"üë§ –ö–æ–Ω—Ç–∞–∫—Ç: {data.get('contact_person', '‚Äî')} | {data.get('phone', '‚Äî')}\n"
            f"üïí –í—Ä–µ–º—è: {data.get('time', '‚Äî')}\n"
            f"üí≥ –°—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã: {'–ø–æ–ª—É—á–µ–Ω–æ' if attachments else '–æ–∂–∏–¥–∞–µ—Ç—Å—è'}"
        )
        if payment_note:
            admin_message += f"\nüìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {payment_note}"

        await self._notify_admins(context, admin_message, media=attachments or None)
        context.user_data.pop("registration", None)

    # ------------------------------------------------------------------
    # Menu handlers

    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        message = update.message
        if message is None:
            return

        self._remember_chat(update, context)

        text, attachments = self._extract_message_payload(message)

        if text == self.MAIN_MENU_BUTTON:
            await self._show_main_menu(update, context)
            return

        profile = self.build_profile(update.effective_chat, update.effective_user)
        pending = context.chat_data.get("pending_admin_action")

        if pending and profile.is_admin:
            if text and text.strip().lower() in self._admin_cancel_tokens:
                context.chat_data.pop("pending_admin_action", None)
                await self._reply(
                    update,
                    "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.\nL'action est annul√©e.",
                    reply_markup=self._admin_menu_markup(),
                )
                return
            context.chat_data.pop("pending_admin_action", None)
            await self._dispatch_admin_action(
                update,
                context,
                pending,
                text=text,
                attachments=attachments,
            )
            return

        if profile.is_admin and text:
            command_text = text.strip()
            if command_text == self.ADMIN_MENU_BUTTON:
                await self._show_admin_menu(update, context)
                return
            if command_text == self.ADMIN_BACK_TO_USER_BUTTON:
                await self._show_main_menu(update, context)
                return
            if command_text == self.ADMIN_BROADCAST_BUTTON:
                context.chat_data["pending_admin_action"] = {"type": "broadcast"}
                await self._reply(
                    update,
                    "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –º–µ–¥–∏–∞ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\n"
                    "Envoyez le message ou les m√©dias √† diffuser."
                    + self.ADMIN_CANCEL_PROMPT,
                    reply_markup=ReplyKeyboardRemove(),
                )
                return
            if command_text == self.ADMIN_EXPORT_TABLE_BUTTON:
                await self._admin_share_registrations_table(update, context)
                return
            if command_text == self.ADMIN_ADD_ADMIN_BUTTON:
                context.chat_data["pending_admin_action"] = {"type": "add_admin"}
                await self._reply(
                    update,
                    "–í–≤–µ–¥–∏—Ç–µ chat_id –Ω–æ–≤–æ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\n"
                    "Entrez le chat_id de l'administrateur."
                    + self.ADMIN_CANCEL_PROMPT,
                    reply_markup=ReplyKeyboardRemove(),
                )
                return
            if command_text == self.ADMIN_EDIT_SCHEDULE_BUTTON:
                await self._prompt_admin_content_edit(
                    update,
                    context,
                    field="schedule",
                    instruction="–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏ –≤–ª–æ–∂–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è."
                    + self.ADMIN_CANCEL_PROMPT,
                )
                return
            if command_text == self.ADMIN_EDIT_ABOUT_BUTTON:
                await self._prompt_admin_content_edit(
                    update,
                    context,
                    field="about",
                    instruction="–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –±–ª–æ–∫ ¬´–û —Å—Ç—É–¥–∏–∏¬ª (—Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ)."
                    + self.ADMIN_CANCEL_PROMPT,
                )
                return
            if command_text == self.ADMIN_EDIT_TEACHERS_BUTTON:
                await self._prompt_admin_content_edit(
                    update,
                    context,
                    field="teachers",
                    instruction="–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–≤—ã–º –æ–ø–∏—Å–∞–Ω–∏–µ–º –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π –∏ –º–µ–¥–∏–∞."
                    + self.ADMIN_CANCEL_PROMPT,
                )
                return
            if command_text == self.ADMIN_EDIT_ALBUM_BUTTON:
                await self._prompt_admin_content_edit(
                    update,
                    context,
                    field="album",
                    instruction="–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –∏–ª–∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è —Ñ–æ—Ç–æ–∞–ª—å–±–æ–º–∞."
                    + self.ADMIN_CANCEL_PROMPT,
                )
                return
            if command_text == self.ADMIN_EDIT_CONTACTS_BUTTON:
                await self._prompt_admin_content_edit(
                    update,
                    context,
                    field="contacts",
                    instruction="–í–≤–µ–¥–∏—Ç–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –∫–æ–Ω—Ç–∞–∫—Ç—ã (–ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Å –º–µ–¥–∏–∞)."
                    + self.ADMIN_CANCEL_PROMPT,
                )
                return
            if command_text == self.ADMIN_EDIT_VOCABULARY_BUTTON:
                await self._prompt_admin_vocabulary_edit(update, context)
                return

        if text:
            await self._handle_menu_selection(update, context)
            return

        if attachments:
            await self._reply(
                update,
                "üìå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n"
                "üìå Merci d'utiliser le menu en bas de l'√©cran.",
                reply_markup=self._main_menu_markup_for(update, context),
            )

    async def _dispatch_admin_action(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        pending: Dict[str, Any],
        *,
        text: str,
        attachments: list[MediaAttachment],
    ) -> None:
        action_type = pending.get("type")
        if action_type == "broadcast":
            await self._admin_send_broadcast(update, context, text, attachments)
            return
        if action_type == "edit_content":
            field = pending.get("field")
            if isinstance(field, str):
                await self._admin_apply_content_update(
                    update,
                    context,
                    field,
                    text=text,
                    attachments=attachments,
                )
            else:
                await self._reply(
                    update,
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—ã–π –±–ª–æ–∫.\n"
                    "Impossible d'identifier la section √† modifier.",
                    reply_markup=self._admin_menu_markup(),
                )
            return
        if action_type == "add_admin":
            await self._admin_add_new_admin(update, context, text)
            return
        if action_type == "edit_vocabulary":
            success = await self._admin_apply_vocabulary_update(update, context, text)
            if not success:
                context.chat_data["pending_admin_action"] = pending
            return
        await self._reply(
            update,
            "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\nAction administrateur inconnue.",
            reply_markup=self._admin_menu_markup(),
        )

    async def _admin_add_new_admin(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE, payload: str
    ) -> None:
        try:
            admin_id = _coerce_chat_id(payload)
        except ValueError:
            await self._reply(
                update,
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ–≤–æ–π chat_id –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\n"
                "Veuillez envoyer un identifiant num√©rique."
                + self.ADMIN_CANCEL_PROMPT,
                reply_markup=ReplyKeyboardRemove(),
            )
            context.chat_data["pending_admin_action"] = {"type": "add_admin"}
            return

        if admin_id in self._runtime_admin_ids:
            await self._reply(
                update,
                "–≠—Ç–æ—Ç chat_id —É–∂–µ –æ–±–ª–∞–¥–∞–µ—Ç –ø—Ä–∞–≤–∞–º–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\n"
                "Cet identifiant est d√©j√† administrateur.",
                reply_markup=self._admin_menu_markup(),
            )
            return

        self._store_dynamic_admin(context, admin_id)
        message = (
            f"‚úÖ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä {admin_id} –¥–æ–±–∞–≤–ª–µ–Ω.\n"
            "‚úÖ Nouvel administrateur ajout√©."
        )
        await self._reply(update, message, reply_markup=self._admin_menu_markup())

        await self._notify_admins(
            context,
            f"üëë –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤: {admin_id} —Ç–µ–ø–µ—Ä—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä.",
        )

    async def _prompt_admin_content_edit(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        *,
        field: str,
        instruction: str,
    ) -> None:
        content = self._get_content(context)
        if not hasattr(content, field):
            await self._reply(
                update,
                "–≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª –Ω–µ–ª—å–∑—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.\nCette section ne peut pas √™tre modifi√©e.",
                reply_markup=self._admin_menu_markup(),
            )
            return
        context.chat_data["pending_admin_action"] = {"type": "edit_content", "field": field}
        current_block = getattr(content, field)
        if isinstance(current_block, ContentBlock):
            text_preview = current_block.text or "(—Ç–µ–∫—Å—Ç–∞ –Ω–µ—Ç)"
            media_note = (
                f"üìé –¢–µ–∫—É—â–∏—Ö –≤–ª–æ–∂–µ–Ω–∏–π: {len(current_block.media)}"
                if current_block.media
                else "üìé –í–ª–æ–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç."
            )
        else:
            text_preview = str(current_block)
            media_note = "üìé –í–ª–æ–∂–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç."
        message = (
            f"{instruction}\n\n"
            "–¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç:"
            f"\n{text_preview}\n{media_note}"
        )
        await self._reply(update, message, reply_markup=ReplyKeyboardRemove())

    async def _prompt_admin_vocabulary_edit(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        content = self._get_content(context)
        context.chat_data["pending_admin_action"] = {"type": "edit_vocabulary"}
        serialized_entries = []
        for entry in content.vocabulary:
            serialized_entries.append(
                "|".join(
                    [
                        entry.get("word", ""),
                        entry.get("emoji", ""),
                        entry.get("translation", ""),
                        entry.get("example_fr", ""),
                        entry.get("example_ru", ""),
                    ]
                )
            )
        sample = "\n".join(serialized_entries) if serialized_entries else "(–ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π)"
        message = (
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ —Å–ª–æ–≤–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: —Å–ª–æ–≤–æ|—ç–º–æ–¥–∑–∏|–ø–µ—Ä–µ–≤–æ–¥|–ø—Ä–∏–º–µ—Ä FR|–ø—Ä–∏–º–µ—Ä RU."
            "\n–ö–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ ‚Äî –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ."
            "\nEnvoyez les entr√©es sous forme: mot|emoji|traduction|phrase FR|phrase RU."
            f"\n\n–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫:\n{sample}"
        )
        await self._reply(update, message + self.ADMIN_CANCEL_PROMPT, reply_markup=ReplyKeyboardRemove())

    async def _admin_send_broadcast(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        message: str,
        attachments: list[MediaAttachment],
    ) -> None:
        known_chats = self._get_known_chats(context)
        if not known_chats:
            await self._reply(
                update,
                "–ü–æ–∫–∞ –Ω–µ—Ç —á–∞—Ç–æ–≤ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\nAucun chat connu pour la diffusion.",
                reply_markup=self._admin_menu_markup(),
            )
            return

        successes = 0
        failures: list[str] = []
        for chat_id in sorted(known_chats):
            try:
                await self._send_payload_to_chat(
                    context,
                    chat_id,
                    text=message if message else None,
                    media=attachments or None,
                )
                successes += 1
            except Exception as exc:  # pragma: no cover - network dependent
                LOGGER.warning("Failed to send broadcast to %s: %s", chat_id, exc)
                failures.append(str(chat_id))

        result = (
            f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {successes} –∏–∑ {len(known_chats)} —á–∞—Ç–æ–≤.\n"
            f"Diffusion envoy√©e: {successes} / {len(known_chats)}."
        )
        if failures:
            result += "\n–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ—Å—Ç–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç—ã: " + ", ".join(failures)
        await self._reply(update, result, reply_markup=self._admin_menu_markup())

    async def _admin_share_registrations_table(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> None:
        registrations = self._application_data(context).get("registrations", [])
        if not isinstance(registrations, list) or not registrations:
            await self._reply(
                update,
                "–ó–∞—è–≤–æ–∫ –ø–æ–∫–∞ –Ω–µ—Ç.\nAucune demande enregistr√©e pour l'instant.",
                reply_markup=self._admin_menu_markup(),
            )
            return

        export_path, generated_at = self._export_registrations_excel(context, registrations)
        preview_lines = self._format_registrations_preview(registrations)
        deeplink = await self._build_registrations_deeplink(context)

        message_parts = [
            "üìä –≠–∫—Å–ø–æ—Ä—Ç –∑–∞—è–≤–æ–∫ –≥–æ—Ç–æ–≤!\n",
            f"üóÇ –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {len(registrations)}",
            f"üïí –û–±–Ω–æ–≤–ª–µ–Ω–æ: {generated_at}",
        ]
        if preview_lines:
            message_parts.append("")
            message_parts.extend(preview_lines)
        if deeplink:
            message_parts.append("")
            message_parts.append(f"üîó –¢–∞–±–ª–∏—Ü–∞: {deeplink}")
            message_parts.append(
                "–ù–∞–∂–º–∏—Ç–µ —Å—Å—ã–ª–∫—É, —á—Ç–æ–±—ã –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –ø–æ–ª—É—á–∏—Ç—å —Å–≤–µ–∂—É—é –≤–µ—Ä—Å–∏—é."
            )
        else:
            message_parts.append("")
            message_parts.append(
                "üîΩ –§–∞–π–ª —Å —Ç–∞–±–ª–∏—Ü–µ–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∏–∂–µ. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –≤ –æ–±–ª–∞–∫–µ Telegram –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞."
            )

        await self._reply(
            update,
            "\n".join(message_parts),
            reply_markup=self._admin_menu_markup(),
        )
        await self._send_registrations_excel(
            update,
            context,
            path=export_path,
            generated_at=generated_at,
        )

    def _export_registrations_excel(
        self,
        context: ContextTypes.DEFAULT_TYPE,
        registrations: list[dict[str, Any]],
    ) -> tuple[Path, str]:
        builder = _SimpleXlsxBuilder(sheet_name="–ó–∞—è–≤–∫–∏")
        builder.add_row(
            (
                "–î–∞—Ç–∞ –∑–∞—è–≤–∫–∏",
                "–ü—Ä–æ–≥—Ä–∞–º–º–∞",
                "–£—á–∞—Å—Ç–Ω–∏–∫",
                "–ö–ª–∞—Å—Å / –≤–æ–∑—Ä–∞—Å—Ç",
                "–ö–æ–Ω—Ç–∞–∫—Ç–Ω–æ–µ –ª–∏—Ü–æ",
                "–¢–µ–ª–µ—Ñ–æ–Ω",
                "–ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è",
                "–û–ø–ª–∞—Ç–∞",
                "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
                "–û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å",
                "–ß–∞—Ç",
            )
        )

        for record in registrations:
            payment_media = record.get("payment_media") or []
            payment_status = "–ü–æ–ª—É—á–µ–Ω–æ" if payment_media else "–û–∂–∏–¥–∞–µ—Ç—Å—è"
            if payment_media:
                payment_status += f" ({len(payment_media)} –≤–ª–æ–∂.)"
            builder.add_row(
                (
                    record.get("created_at") or "",
                    record.get("program") or "",
                    record.get("child_name") or "",
                    record.get("class") or "",
                    record.get("contact_person") or "",
                    record.get("phone") or "",
                    record.get("time") or "",
                    payment_status,
                    record.get("payment_note") or "",
                    record.get("submitted_by") or "",
                    record.get("chat_title") or "",
                )
            )

        generated_at = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        export_path = Path("data") / "exports" / "confetti_registrations.xlsx"
        builder.to_file(export_path)

        storage = self._application_data(context)
        exports_meta = storage.setdefault("exports", {})
        if isinstance(exports_meta, dict):
            exports_meta["registrations"] = {
                "generated_at": generated_at,
                "path": str(export_path),
            }
        else:
            storage["exports"] = {
                "registrations": {
                    "generated_at": generated_at,
                    "path": str(export_path),
                }
            }

        return export_path, generated_at

    def _format_registrations_preview(
        self, registrations: list[dict[str, Any]]
    ) -> list[str]:
        if not registrations:
            return []

        preview = ["üÜï –ü–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞—è–≤–∫–∏:"]
        latest = registrations[-3:]
        for record in reversed(latest):
            child = record.get("child_name") or "‚Äî"
            program = record.get("program") or "‚Äî"
            created = record.get("created_at") or "‚Äî"
            preview.append(f"‚Ä¢ {child} | {program} | {created}")
        remaining = len(registrations) - len(latest)
        if remaining > 0:
            preview.append(f"‚Ä¶–∏ –µ—â—ë {remaining} –∑–∞–ø–∏—Å–µ–π –≤ —Ç–∞–±–ª–∏—Ü–µ")
        return preview

    async def _build_registrations_deeplink(
        self, context: ContextTypes.DEFAULT_TYPE
    ) -> Optional[str]:
        if self._bot_username:
            return f"https://t.me/{self._bot_username}?start=registrations_excel"

        try:
            me = await context.bot.get_me()
        except Exception as exc:  # pragma: no cover - network dependent
            LOGGER.debug("Failed to resolve bot username: %s", exc)
            return None

        username = getattr(me, "username", None)
        if not username:
            return None

        self._bot_username = username
        return f"https://t.me/{username}?start=registrations_excel"

    async def _send_registrations_excel(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        *,
        path: Optional[Path] = None,
        generated_at: Optional[str] = None,
    ) -> bool:
        chat = update.effective_chat
        if chat is None:
            return False

        registrations = self._application_data(context).get("registrations", [])
        if path is None or generated_at is None:
            if not isinstance(registrations, list) or not registrations:
                await self._reply(
                    update,
                    "–ó–∞—è–≤–æ–∫ –ø–æ–∫–∞ –Ω–µ—Ç.\nAucune demande enregistr√©e pour l'instant.",
                    reply_markup=self._admin_menu_markup(),
                )
                return False
            path, generated_at = self._export_registrations_excel(context, registrations)

        try:
            chat_id = _coerce_chat_id_from_object(chat)
        except ValueError:
            return False

        caption = (
            "üìä Tableau des inscriptions Confetti\n"
            f"–û–±–Ω–æ–≤–ª–µ–Ω–æ: {generated_at}\n"
            "–î–æ–∫—É–º–µ–Ω—Ç –≤–∫–ª—é—á–∞–µ—Ç –≤—Å–µ –∑–∞—è–≤–∫–∏ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º —ç–∫—Å–ø–æ—Ä—Ç–µ."
        )

        try:
            with path.open("rb") as handle:
                await context.bot.send_document(
                    chat_id=chat_id,
                    document=handle,
                    filename=path.name,
                    caption=caption,
                )
        except Exception as exc:  # pragma: no cover - network dependent
            LOGGER.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É –∑–∞—è–≤–æ–∫: %s", exc)
            return False

        return True

    async def _admin_apply_content_update(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        field: str,
        *,
        text: str,
        attachments: list[MediaAttachment],
    ) -> None:
        content = self._get_content(context)
        if not hasattr(content, field):
            await self._reply(
                update,
                "–≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª –Ω–µ–ª—å–∑—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.\nCette section ne peut pas √™tre modifi√©e.",
                reply_markup=self._admin_menu_markup(),
            )
            return
        block = getattr(content, field)
        new_block = ContentBlock(
            text=text.strip(),
            media=[MediaAttachment(kind=item.kind, file_id=item.file_id, caption=item.caption) for item in attachments],
        )
        if isinstance(block, ContentBlock):
            block.text = new_block.text
            block.media = new_block.media
        else:
            setattr(content, field, new_block)
        label = self.CONTENT_LABELS.get(field, field)
        await self._reply(
            update,
            "–†–∞–∑–¥–µ–ª –æ–±–Ω–æ–≤–ª—ë–Ω!\nLa section a √©t√© mise √† jour.",
            reply_markup=self._admin_menu_markup(),
        )
        await self._notify_admins(
            context,
            f"üõ† –†–∞–∑–¥–µ–ª ¬´{label}¬ª –±—ã–ª –æ–±–Ω–æ–≤–ª—ë–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.",
            media=attachments or None,
        )

    async def _admin_apply_vocabulary_update(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE, payload: str
    ) -> bool:
        lines = [line.strip() for line in payload.splitlines() if line.strip()]
        if not lines:
            await self._reply(
                update,
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Å –¥–∞–Ω–Ω—ã–º–∏.\nVeuillez fournir au moins une entr√©e."
                + self.ADMIN_CANCEL_PROMPT,
                reply_markup=ReplyKeyboardRemove(),
            )
            return False

        entries: list[dict[str, str]] = []
        for line in lines:
            parts = [part.strip() for part in line.split("|")]
            if len(parts) != 5:
                await self._reply(
                    update,
                    "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 5 —á–∞—Å—Ç–µ–π —á–µ—Ä–µ–∑ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é —á–µ—Ä—Ç—É.\n"
                    "Format incorrect: 5 √©l√©ments s√©par√©s par |."
                    + self.ADMIN_CANCEL_PROMPT,
                    reply_markup=ReplyKeyboardRemove(),
                )
                return False
            entries.append(
                {
                    "word": parts[0],
                    "emoji": parts[1],
                    "translation": parts[2],
                    "example_fr": parts[3],
                    "example_ru": parts[4],
                }
            )

        content = self._get_content(context)
        content.vocabulary = entries
        await self._reply(
            update,
            f"–û–±–Ω–æ–≤–ª–µ–Ω–æ —Å–ª–æ–≤: {len(entries)}.\nNombre d'entr√©es: {len(entries)}.",
            reply_markup=self._admin_menu_markup(),
        )
        return True


    async def _handle_menu_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        text = (update.message.text or "").strip()
        handlers = {
            "üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ / Horaires": self._send_schedule,
            "‚ÑπÔ∏è –û —Å—Ç—É–¥–∏–∏ / √Ä propos de nous": self._send_about,
            "üë©‚Äçüè´ –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏ / Enseignants": self._send_teachers,
            "üì∏ –§–æ—Ç–æ–∞–ª—å–±–æ–º / Album photo": self._send_album,
            "üìû –ö–æ–Ω—Ç–∞–∫—Ç—ã / Contact": self._send_contacts,
            "üìö –ü–æ–ª–µ–∑–Ω—ã–µ —Å–ª–æ–≤–∞ / Vocabulaire": self._send_vocabulary,
        }

        handler = handlers.get(text)
        if handler is None:
            await self._reply(
                update,
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –º–µ–Ω—é –≤–Ω–∏–∑—É —ç–∫—Ä–∞–Ω–∞.\n"
                "Merci de choisir une option dans le menu ci-dessous.",
                reply_markup=self._main_menu_markup_for(update, context),
            )
            return
        await handler(update, context)

    async def _send_content_block(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE, block: ContentBlock
    ) -> None:
        text = block.text.strip() if block.text else ""
        media = block.media or None
        reply_markup = self._main_menu_markup_for(update, context)
        if text:
            await self._reply(update, text, reply_markup=reply_markup, media=media)
            return
        if media:
            await self._reply(
                update,
                "üìé –ú–∞—Ç–µ—Ä–∏–∞–ª –¥–æ—Å—Ç—É–ø–µ–Ω –≤–æ –≤–ª–æ–∂–µ–Ω–∏—è—Ö.\nüìé Contenu disponible en pi√®ce jointe.",
                reply_markup=reply_markup,
                media=media,
            )
            return
        await self._reply(
            update,
            "–†–∞–∑–¥–µ–ª –ø–æ–∫–∞ –ø—É—Å—Ç.\nCette section est vide pour le moment.",
            reply_markup=reply_markup,
        )

    async def _send_schedule(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        content = self._get_content(context)
        await self._send_content_block(update, context, content.schedule)

    async def _send_about(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        content = self._get_content(context)
        await self._send_content_block(update, context, content.about)

    async def _send_teachers(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        content = self._get_content(context)
        await self._send_content_block(update, context, content.teachers)

    async def _send_album(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        content = self._get_content(context)
        await self._send_content_block(update, context, content.album)

    async def _send_contacts(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        content = self._get_content(context)
        await self._send_content_block(update, context, content.contacts)

    async def _send_vocabulary(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        content = self._get_content(context)
        if not content.vocabulary:
            await self._reply(
                update,
                "–°–ø–∏—Å–æ–∫ —Å–ª–æ–≤ –ø–æ–∫–∞ –ø—É—Å—Ç. –î–æ–±–∞–≤—å—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —á–µ—Ä–µ–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å.\n"
                "La liste de vocabulaire est vide pour le moment.",
                reply_markup=self._main_menu_markup_for(update, context),
            )
            return
        entry = random.choice(content.vocabulary)
        text = (
            "üéÅ Mot du jour / –°–ª–æ–≤–æ –¥–Ω—è :\n\n"
            f"üá´üá∑ {entry.get('word', '‚Äî')} {entry.get('emoji', '')}\n"
            f"üá∑üá∫ {entry.get('translation', '‚Äî')}\n\n"
            f"üí¨ Exemple : {entry.get('example_fr', '‚Äî')} ‚Äî {entry.get('example_ru', '‚Äî')}"
        )
        await self._reply(update, text, reply_markup=self._main_menu_markup_for(update, context))


@dataclass(frozen=True)
class UserProfile:
    """Representation of a standard chat profile."""

    chat_id: int
    role: str = field(init=False, default="user")

    @property
    def is_admin(self) -> bool:
        return False


@dataclass(frozen=True)
class AdminProfile(UserProfile):
    """Profile granted elevated permissions."""

    role: str = field(init=False, default="admin")

    @property
    def is_admin(self) -> bool:
        return True


class _SimpleXlsxBuilder:
    """Minimal XLSX writer for structured admin exports."""

    def __init__(self, sheet_name: str = "Sheet1") -> None:
        self.sheet_name = self._sanitise_sheet_name(sheet_name)
        self.rows: list[list[str]] = []

    def add_row(self, values: Iterable[Any]) -> None:
        row: list[str] = []
        for value in values:
            if value is None:
                row.append("")
            else:
                row.append(str(value))
        self.rows.append(row)

    def to_file(self, path: Path) -> None:
        path.parent.mkdir(parents=True, exist_ok=True)
        with ZipFile(path, "w", ZIP_DEFLATED) as archive:
            archive.writestr("[Content_Types].xml", self._content_types())
            archive.writestr("_rels/.rels", self._rels_root())
            archive.writestr("xl/workbook.xml", self._workbook())
            archive.writestr("xl/_rels/workbook.xml.rels", self._workbook_rels())
            archive.writestr("xl/styles.xml", self._styles())
            archive.writestr("xl/worksheets/sheet1.xml", self._sheet())

    def _sheet(self) -> str:
        rows_xml: list[str] = []
        for row_index, row in enumerate(self.rows, start=1):
            cells: list[str] = []
            for column_index, value in enumerate(row):
                cell_reference = f"{self._column_letter(column_index)}{row_index}"
                style = ' s="1"' if row_index == 1 else ""
                text = escape(value, {"\n": "&#10;"})
                cells.append(
                    f'<c r="{cell_reference}" t="inlineStr"{style}><is><t>{text}</t></is></c>'
                )
            rows_xml.append(f'<row r="{row_index}">{"".join(cells)}</row>')

        sheet_data = "".join(rows_xml)
        return (
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
            "<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" "
            "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">"
            f"<sheetData>{sheet_data}</sheetData>"
            "</worksheet>"
        )

    def _workbook(self) -> str:
        return (
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
            "<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" "
            "xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">"
            "<sheets>"
            f"<sheet name=\"{escape(self.sheet_name)}\" sheetId=\"1\" r:id=\"rId1\"/>"
            "</sheets>"
            "</workbook>"
        )

    @staticmethod
    def _content_types() -> str:
        return (
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
            "<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">"
            "<Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>"
            "<Default Extension=\"xml\" ContentType=\"application/xml\"/>"
            "<Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>"
            "<Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>"
            "<Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>"
            "</Types>"
        )

    @staticmethod
    def _rels_root() -> str:
        return (
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
            "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">"
            "<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/>"
            "</Relationships>"
        )

    @staticmethod
    def _workbook_rels() -> str:
        return (
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
            "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">"
            "<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet1.xml\"/>"
            "<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\"/>"
            "</Relationships>"
        )

    @staticmethod
    def _styles() -> str:
        return (
            "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
            "<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">"
            "<fonts count=\"2\">"
            "<font><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/></font>"
            "<font><b/><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/></font>"
            "</fonts>"
            "<fills count=\"1\"><fill><patternFill patternType=\"none\"/></fill></fills>"
            "<borders count=\"1\"><border><left/><right/><top/><bottom/><diagonal/></border></borders>"
            "<cellStyleXfs count=\"1\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\"/></cellStyleXfs>"
            "<cellXfs count=\"2\">"
            "<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" xfId=\"0\"/>"
            "<xf numFmtId=\"0\" fontId=\"1\" fillId=\"0\" borderId=\"0\" xfId=\"0\" applyFont=\"1\"/>"
            "</cellXfs>"
            "<cellStyles count=\"1\"><cellStyle name=\"Normal\" xfId=\"0\" builtinId=\"0\"/></cellStyles>"
            "</styleSheet>"
        )

    @staticmethod
    def _column_letter(index: int) -> str:
        result = ""
        while index >= 0:
            index, remainder = divmod(index, 26)
            result = chr(65 + remainder) + result
            index -= 1
        return result

    @staticmethod
    def _sanitise_sheet_name(name: str) -> str:
        sanitized = re.sub(r"[\\/*?:\[\]]", "", name).strip()
        if not sanitized:
            sanitized = "Sheet1"
        return sanitized[:31]


def _normalise_admin_chat_ids(chat_ids: AdminChatIdsInput) -> frozenset[int]:
    """Return a normalised, deduplicated set of admin chat identifiers."""

    result: set[int] = set()
    for candidate in _iter_chat_id_candidates(chat_ids):
        for part in _split_candidate(candidate):
            result.add(_coerce_chat_id(part))
    return frozenset(result)


def _iter_chat_id_candidates(value: AdminChatIdsInput) -> Iterable[ChatIdInput]:
    if value is None:
        return ()
    if isinstance(value, (str, bytes)):
        return (value,)
    if isinstance(value, Iterable):
        return tuple(value)
    return (value,)


def _split_candidate(candidate: ChatIdInput) -> Iterable[ChatIdInput]:
    if isinstance(candidate, str):
        parts = [part.strip() for part in candidate.split(",")]
        return tuple(part for part in parts if part)
    return (candidate,)


def _coerce_chat_id(value: ChatIdInput) -> int:
    if isinstance(value, bool):
        raise ValueError("Boolean values cannot represent a chat id")
    if isinstance(value, str):
        stripped = value.strip()
        if not stripped:
            raise ValueError("Chat id strings cannot be empty")
        value = stripped
    try:
        return int(value)
    except (TypeError, ValueError) as exc:  # pragma: no cover - guard clause
        raise ValueError(f"Invalid chat id: {value!r}") from exc


def _coerce_chat_id_from_object(chat: Any) -> int:
    if hasattr(chat, "id"):
        chat = getattr(chat, "id")
    return _coerce_chat_id(chat)  # type: ignore[arg-type]


def main() -> None:  # pragma: no cover - thin wrapper
    """Entry point used by the console script in the original project."""

    logging.basicConfig(level=logging.INFO)

    _load_environment_files()

    token = _resolve_bot_token()
    if token is None:
        LOGGER.error(
            "Bot token is not configured. Set one of %s or provide a file path via %s",
            ", ".join(TOKEN_ENVIRONMENT_KEYS),
            ", ".join(TOKEN_FILE_ENVIRONMENT_KEYS),
        )
        raise SystemExit(1)

    admin_chat_ids = os.environ.get("CONFETTI_ADMIN_CHAT_IDS", "")

    try:
        _require_telegram()
    except RuntimeError as exc:
        LOGGER.error("%s", exc)
        raise SystemExit(1) from exc

    bot = ConfettiTelegramBot(token=token, admin_chat_ids=admin_chat_ids)
    application = bot.build_application()
    # The original project keeps polling outside of the kata scope.  We expose
    # the configured application so that callers can decide how to run it.
    application.run_polling()


TOKEN_ENVIRONMENT_KEYS: tuple[str, ...] = (
    "CONFETTI_BOT_TOKEN",
    "TELEGRAM_BOT_TOKEN",
    "BOT_TOKEN",
    "TELEGRAM_TOKEN",
    "CONFETTI_TOKEN",
)

TOKEN_FILE_ENVIRONMENT_KEYS: tuple[str, ...] = (
    "CONFETTI_BOT_TOKEN_FILE",
    "TELEGRAM_BOT_TOKEN_FILE",
    "BOT_TOKEN_FILE",
    "TELEGRAM_TOKEN_FILE",
    "CONFETTI_BOT_TOKEN_PATH",
)


def _resolve_bot_token() -> Optional[str]:
    """Read the bot token from the environment and validate it."""

    for key in TOKEN_ENVIRONMENT_KEYS:
        token = os.environ.get(key)
        if token:
            token = token.strip()
            if token and token != "TOKEN_PLACEHOLDER":
                return token

    for key in TOKEN_FILE_ENVIRONMENT_KEYS:
        token_path = os.environ.get(key)
        if token_path:
            token = _read_token_file(Path(token_path))
            if token:
                return token
    return None


def _load_environment_files() -> None:
    """Populate ``os.environ`` with values from common dotenv files."""

    base_dir = Path(__file__).resolve().parent
    for filename in (".env", ".env.local"):
        _apply_env_file(base_dir / filename)


def _apply_env_file(path: Path) -> None:
    if not path.exists() or not path.is_file():
        return

    try:
        content = path.read_text(encoding="utf-8")
    except OSError as exc:  # pragma: no cover - filesystem dependent
        LOGGER.warning("Failed to read environment file %s: %s", path, exc)
        return

    for line in content.splitlines():
        parsed = _parse_env_assignment(line)
        if not parsed:
            continue
        key, value = parsed
        if key in os.environ:
            continue
        os.environ[key] = value


def _parse_env_assignment(line: str) -> Optional[tuple[str, str]]:
    """Parse a dotenv-style assignment returning ``(key, value)`` when valid."""

    stripped = line.strip()
    if not stripped or stripped.startswith("#"):
        return None

    if stripped.startswith("export "):
        stripped = stripped[len("export ") :].lstrip()

    if "=" not in stripped:
        LOGGER.debug("Ignoring malformed environment line: %s", line)
        return None

    key, value = stripped.split("=", 1)
    key = key.strip()
    value = value.strip()

    if not key:
        LOGGER.debug("Ignoring environment line with empty key: %s", line)
        return None

    if value and value[0] == value[-1] and value[0] in {'"', "'"}:
        value = value[1:-1]

    return key, value


def _read_token_file(path: Path) -> Optional[str]:
    try:
        token = path.read_text(encoding="utf-8").strip()
    except OSError as exc:  # pragma: no cover - filesystem dependent
        LOGGER.warning("Unable to read token file %s: %s", path, exc)
        return None

    if token and token != "TOKEN_PLACEHOLDER":
        return token
    return None


if __name__ == "__main__":  # pragma: no cover - module executable guard
    main()
